# How to inject dependencies into feature modules

In order to pass dependencies into a related feature module this document proposes for us to standardize a form of dependency injection provided by Ubers [Needle](https://github.com/uber/needle) DI framework.

Needle is similar to what Android engineer's use (Dagger). It instead of relying on metaprogramming or reflection capabilities of the runtime enables compile time safety, meaning if some dependency is not resolved the app instead of crashing wonâ€™t be able to build at all.

It uses [SourceKit](https://github.com/apple/sourcekit-lsp) to parse Swift source files, generating from them an in-memory graph where nodes are derived from the ```Component``` subclasses while vertices that connect these nodes are represented by the ```Dependency``` protocol.

The final product of this graph is a Swift source file which we will label as DIGenerated.swift. This file is generated by Needle's command line tool, either manually invoked from a shell or as a build script, and is commited to source control. This file is what unlocks compile time safety for providing dependencies, as when a dependancy is missing or somehow not resolved the build system won't be able to produce the final product.

## How to use Needle?
Main building blocks are the [Component](https://github.com/uber/needle/blob/df2f9a7b7b6743752179f8e21d299596fb234fb6/Sources/NeedleFoundation/Component.swift#L39) subclass as well as the [Dependency](https://github.com/uber/needle/blob/df2f9a7b7b6743752179f8e21d299596fb234fb6/Sources/NeedleFoundation/Component.swift#L20) protocol. We use these blocks in order to build the dependency graph required for constructing the DIGenerated.swift file.

For Needle CLI tool to generate the DIGenerated.swift we first must create an empty DIGenerate.swift file in a folder of our choice, then we pass on the location of this file as well as the destination of the source files to the CLI tool. This step is best handled as a build script, though sometimes it is necessary to manually perform. 

Each graph starts with a root node, this node propagates dependencies downards to its children. The dependancies of the root node itself should be provided outside of the module via a `bootstrap` global function. This function takes in a set of parameters which are the actual dependencies that are passed on into Needle and are used to generate the graph and represent the fuel on which the engine of the module runs on.

In a modular system such as iStory, each feature module should publicly expose a `RootComponent`, the constructor (init) of this component must stay internal to the module itself, as only a `bootstrap` function should be allowed to construct the root node since it is an entry point of the module itself. For a contrived example on how a setup with Needle may look like, please look at the `Onboarding` framework and for its usage please see `OnboardingTestApp`.

## How to setup Needle in a feature module?
1. Open project settings and navigate to the Swift Packages tab
2. Download and link `NeedleFoundation` via SPM by providing it the repository url: https://github.com/uber/needle.git
3. In the build phases tab of the target, create a new build script phase named needle and add the following script: 
```
export SOURCEKIT_LOGGING=0 && needle generate ${module_name}/DI/DIGenerated.swift ${module_name}/Components
```
4. In the root folder group of the target, add a `Components` folder in which nodes that needle parses will be placed.
5. In the root folder group of the target, add a `DI` folder. Once the build script executes, drag and drop the generated DIGenerated.swift file into the DI folder so that it is visible to Xcode.
6. Once components have been created (specifically the `RootComponent` is a must) create a `bootstrap` function that acts as the module entry point. Implementation details of this function must contain a call to `registerProviderFactories()` which is generated by `NeedleFoundation` in the DIGenerated.swift file.
```swift
public func bootstrap(splashDuration: TimeInterval, bundle: Bundle) -> RootComponent {
    registerProviderFactories()
    return RootComponent(splashDuration: splashDuration, bundle: bundle)
}
```
## Future directions
The entirety of the setup above may be extracted into an xcode template, though in the development phase of iStory we don't expect introducing a substantial amount of feature modules hence this would be a wasted effort. Instead we may want to focus at some point on introducing a sort of orchestrator object that for us manages the flow of the dependencies into the modules and lazily loads them on demand. 

Also it might make sense to at some point introduce scopes (access control) so that based on a given state some modules may or may not be allocated/deallocated. Further discussion of such topis is beyond the scope of this document but could be covered in a separate one.
